
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Android Platform Framework Design - My Octopress Blog</title>
	<meta name="author" content="Your Name">

	
	<meta name="description" content="Android Platform Framework Design Android端架构解析 应用架构设计 通常我们把模块划分成： 基础模块 : 指核心库，其中核心部分包含：网络连接、消息通信、依赖注入、缓存策略等等，框架部分是一个RESTful Client App的实现， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://znyang.github.io/blog/2014/07/22/android-platform-framework-design/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
	<li><a href="/android">Android</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Android Platform Framework Design</h1>
	<div class="entry-content" itemprop="articleBody"><h1>Android端架构解析</h1>

<h2>应用架构设计</h2>

<p><img src="/images/blog/app.png" alt="" /></p>

<p>通常我们把模块划分成：</p>

<ul>
<li><strong>基础模块</strong> : 指核心库，其中核心部分包含：网络连接、消息通信、依赖注入、缓存策略等等，框架部分是一个RESTful Client App的实现，包含IntentService、RequestManager等实现；<code>Hermes</code>是我们正在整理的核心库和框架，当你搭建好了开发环境，就可以从这里开始(<code>hermes-demo</code>)，<strong>旧项目中使用的核心库名称是Up91Core</strong></li>
<li><strong>通用模块</strong> : 包括：与项目无关的基础业务模块(hy-sdk)、通用UI模块(UI Commons)、统计分析/检查更新(Update/Analytic)等</li>
<li><strong>功能模块</strong> : 作答模块(Exercise)、阅读模块(Reader)、视频模块(Video)。 这些模块有可能根据项目的不同表现出不同的业务逻辑，他们通常需要完整的接入文档和示例。 这些模块应当设计的尽可能轻量级，例如：将网络请求功能设计成获取数据的接口，从而反向依赖于模块的使用者。</li>
<li><strong>项目模块</strong> : 即主项目模块，是功能模块的直接使用者，当一个项目需要个功能时，需要在这个项目中做模块集成。 (注: AppResource是项目的可替换资源模块，在构建期使用不同版本的资源模块可以达到更换主题/皮肤(如：非学历项目)的效果，动态切换皮肤则使用资源引用方式实现(如: 91up学习平台项目))</li>
</ul>


<h2>hermes-framework</h2>

<h3>逻辑分层架构</h3>

<p><img src="/images/blog/runtime_frame.png" alt="" /></p>

<h3>数据加载过程实现</h3>

<p><img src="/images/blog/hermes-frame.png" alt="" /></p>

<ol>
<li><strong>注册服务</strong> 应用启动后注册服务类，在需要处理请求时，服务会自动开启，在处理完请求后30秒内不再收到请求时会自动关闭服务，以节省资源；</li>
<li><strong>数据绑定(订阅)</strong> Activity通过创建CursorLoader来订阅感兴趣的数据；</li>
<li><strong>异步请求</strong> 创建一个Request发送给RequestService，由Service分配一个工作线程来创建与Request相应的处理器(Operation)，在处理器中执行异步操作；</li>
<li><strong>数据更新</strong> 在Operation执行过程中可以访问远程api获取新数据，并更新到db中（通过ContentProvider），而CursorLoader会在ContentProvider数据变化时通知LoaderCallback，这时页面上的数据会自动刷新</li>
</ol>


<p><strong>界面上的处理过程如下</strong>：
<img src="/images/blog/view-process.png" alt="" /></p>

<p><strong>特点</strong>：</p>

<ol>
<li>异步请求通过<code>Service</code>的线程池来执行，更加稳定，便于<strong>线程管理</strong>；</li>
<li><strong>数据绑定</strong>写法更统一，数据更新时无需返回结果数据，而是直接写入db，数据更新后订阅者即可呈现新数据；</li>
<li><code>Request</code>提交时，能<strong>自动去重</strong>。 两次相同的<code>Request</code>（参数一致）在第二次sendRequest时，如果第一次未执行完毕，本次仅创建新的回调接收器，不会产生多次操作，提高效率；</li>
<li><code>Request</code>可设置<strong>优先级</strong>，在多个请求并发时，更高优先级的<code>Request</code>优先处理，可以带来更好的用户体验。</li>
</ol>


<p><strong>问题</strong>:</p>

<ol>
<li>db部分的代码目前使用生成器产生(ContentProvider实现类)，再由Dao执行CURD操作，有一定的重复代码；</li>
<li>子模块无法直接使用这套方案，异步加载过程自行实现(AsyncTask)</li>
</ol>


<h3>通用Cache实现方案 (备选)</h3>

<p><img src="/images/blog/request_cache.png" alt="" /></p>

<p>与上一个方案的差别在于，没有<strong>数据绑定</strong>过程，数据刷新都是通过请求的回调来处理。</p>

<p><strong>优点</strong></p>

<ol>
<li>实现简单，无需编写Dao操作代码，无需数据绑定过程；</li>
<li>易于理解，界面无需关心数据来源是本地还是远程；</li>
</ol>


<p><strong>问题</strong></p>

<ol>
<li>缺少数据库管理，不支持深入的CRUD操作，仅通过参数映射</li>
<li>数据存储相对较大</li>
<li>没有数据绑定过程，每个页面只能自己主动请求刷新数据</li>
</ol>


<blockquote><p>Google Volley的cache实现也是使用这个方案，数据过期时间由接口返回的Expires值决定。</p></blockquote>

<h2>消息通信</h2>

<p>在App中处理界面、模块、组件之间的数据通信时，通常可以使用不同的解决方案，比较我们项目中比较常用的是广播(Broadcast)和事件总线(EventBus)</p>

<h3>广播 (Broadcast)</h3>

<blockquote><p>比较通用的平台解决方案，在需要订阅事件的组件中注册关注的广播事件接收器，在广播事件发布时，收到广播并处理相应的业务逻辑。</p></blockquote>

<p><strong>特点</strong></p>

<ol>
<li>Android平台通用方案，稳定可靠</li>
<li>数据收发使用基础类型，不依赖具体数据模型，可以在任意模块中传递</li>
<li>可以在应用间传递数据</li>
<li>可以接收系统事件，例如：网络连接状态等</li>
</ol>


<p><strong>问题</strong></p>

<ol>
<li>写法相对繁琐</li>
<li>滥用会产生太多广播事件，对系统和应用产生性能影响</li>
</ol>


<p><strong>适用范围</strong></p>

<ol>
<li>接收系统事件</li>
<li>使用本地广播发送广播事件 (对外部应用无影响)</li>
<li>功能模块间通信（特别是第三方模块通信）</li>
</ol>


<blockquote><p>如果我们往外部提供组件，一般就是使用广播来做数据通信</p></blockquote>

<h3>事件总线 (EventBus)</h3>

<p>回顾下之前在Android App中组件通信的实现有哪些？</p>

<ol>
<li><strong>传递接口实现对象</strong> ：设计直观，简单通信</li>
<li><strong>观察者模式</strong> ：可以一对多，当界面组件复杂需要多对多通信时无法管理</li>
<li><strong>本地广播</strong></li>
</ol>


<p>事件总线提供一个通用的组件通信解决方案，使组件间耦合度降低，事件发布、订阅过程简单化，特别适合多组件间通信</p>

<p><img src="/images/blog/event_bus.png" alt="" /></p>

<h2>Image Loader</h2>

<p>ImageLoader重要性：当应用中需要呈现大量图片时，对于图片资源的管理就显得相当重要，目前有很多image-loader的实现库，比如volley, Picasso, Universal-Image-Loader 等等，比较通用的设计方式如图：</p>

<p><img src="/images/blog/image_loader.png" alt="" /></p>

<p><strong>ImageLoader</strong>会从上往下一级一级的查询图片资源，通过多级缓存的设计提高缓存效率，并兼顾内存使用大小。</p>

<ul>
<li><strong>LruCache</strong> memory cache的实现类，当图片缓存超出memory cache限定大小时，会remove掉部分图片资源，以保证内存使用不会溢出；</li>
<li><strong>DiskImageCache</strong> 保存在存储设备中的图片缓存，通常会限定一个合适的存储空间来保存图片；</li>
</ul>


<blockquote><p>不同的image-loader实现库之间，差别在于性能，api设计，可扩展性上。</p></blockquote>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>


</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Your Name


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>
